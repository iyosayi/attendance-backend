import dotenv from 'dotenv';
import mongoose from 'mongoose';
import fs from 'fs';
import csv from 'csv-parser';
import path from 'path';
import User from '../src/models/User';
import Camper from '../src/models/Camper';
import logger from '../src/utils/logger';

// Load environment variables
dotenv.config();

interface CsvRow {
  firstName: string;
  lastName: string;
  phone?: string;
  email?: string;
  [key: string]: string | undefined;
}

const isValidEmail = (email: string): boolean => {
  if (!email || !email.trim()) return false;
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email.trim());
};

const normalizePhone = (phone: string | undefined): string => {
  if (!phone || !phone.trim()) return '0000000000';
  // Remove all non-digit characters
  return phone.replace(/\D/g, '') || '0000000000';
};

const bulkCreateCampers = async () => {
  try {
    // Connect to MongoDB
    const mongoURI = process.env.MONGODB_URI || 'mongodb://localhost:27017/camp-attendance';
    await mongoose.connect(mongoURI);

    logger.info('Connected to MongoDB');
    console.log('\n‚úÖ Connected to MongoDB\n');

    // Get admin user
    const adminUser = await User.findOne({ email: 'admin@camp.com' });

    if (!adminUser) {
      console.error('‚ùå Admin user not found. Please run `npm run seed:admin` first');
      process.exit(1);
    }

    console.log(`üë§ Using admin user: ${adminUser.email}\n`);

    // Get CSV file path from command line argument or use default
    const csvFileName = process.argv[2] || 'campers.csv';
    const csvPath = path.join(__dirname, '..', csvFileName);

    // Check if CSV file exists
    if (!fs.existsSync(csvPath)) {
      console.error(`‚ùå Error: CSV file not found at ${csvPath}`);
      console.log('\nUsage: npm run bulk:campers [csv-file-path]');
      console.log('\nExample:');
      console.log('  npm run bulk:campers campers.csv');
      console.log('  npm run bulk:campers data/campers.csv');
      console.log('\nCSV format (required columns):');
      console.log('  firstName,lastName,phone,email');
      console.log('\nExample CSV content:');
      console.log('  firstName,lastName,phone,email');
      console.log('  John,Doe,1234567890,john@example.com');
      console.log('  Jane,Smith,,jane@example.com');
      console.log('  Bob,Johnson,0987654321,');
      console.log('  Alice,Williams,,');
      console.log('\nNote: phone and email are optional and can be empty');
      process.exit(1);
    }

    // Read and parse CSV
    const rows: CsvRow[] = [];

    await new Promise<void>((resolve, reject) => {
      fs.createReadStream(csvPath)
        .pipe(csv())
        .on('data', (row) => rows.push(row))
        .on('end', () => resolve())
        .on('error', (error) => reject(error));
    });

    console.log(`üìÑ Found ${rows.length} rows in CSV\n`);

    if (rows.length === 0) {
      console.log('‚ö†Ô∏è  No data found in CSV file');
      await mongoose.disconnect();
      process.exit(0);
    }

    // Process and validate data
    const campersToInsert: any[] = [];
    const errors: any[] = [];
    const duplicates: string[] = [];
    const autogeneratedEmails: string[] = [];
    let autogeneratedEmailCounter = 1;

    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      const rowNumber = i + 2; // +2 because CSV has header and arrays are 0-indexed

      // Skip empty rows
      if (!row.firstName && !row.lastName) {
        continue;
      }

      // Trim fields
      const firstName = row.firstName?.trim() || '';
      const lastName = row.lastName?.trim() || '';
      const phoneRaw = row.phone?.trim() || '';
      const emailRaw = row.email?.trim() || '';

      // Validate required fields
      if (!firstName || !lastName) {
        errors.push({
          row: rowNumber,
          reason: 'Missing required fields (firstName or lastName)',
          data: { firstName, lastName },
        });
        continue;
      }

      // Normalize phone
      const phone = normalizePhone(phoneRaw);

      // Handle email - generate if missing or invalid
      let email = emailRaw;
      if (!email || !isValidEmail(email)) {
        // Generate unique dummy email
        const timestamp = Date.now();
        email = `autogenerated-${timestamp}-${autogeneratedEmailCounter}@camp.com`;
        autogeneratedEmailCounter++;
        const originalEmail = emailRaw ? `"${emailRaw}"` : 'empty';
        autogeneratedEmails.push(
          `Row ${rowNumber}: ${firstName} ${lastName} - Original: ${originalEmail} ‚Üí Generated: "${email}"`
        );
      }

      // Check for duplicates within the CSV itself (by email)
      if (campersToInsert.some(c => c.email.toLowerCase() === email.toLowerCase())) {
        duplicates.push(`Row ${rowNumber}: ${firstName} ${lastName} (${email}) - duplicate email in CSV`);
        continue;
      }

      // Build camper object
      const camper = {
        firstName,
        lastName,
        email: email.toLowerCase(),
        phone,
        status: 'pending',
        createdBy: adminUser._id,
        updatedBy: adminUser._id,
        isDeleted: false,
      };

      campersToInsert.push(camper);
    }

    // Display summary before import
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üìä Import Summary');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log(`Total rows in CSV:       ${rows.length}`);
    console.log(`Valid campers to import: ${campersToInsert.length}`);
    console.log(`Duplicates skipped:      ${duplicates.length}`);
    console.log(`Autogenerated emails:    ${autogeneratedEmails.length}`);
    console.log(`Errors/Invalid rows:     ${errors.length}`);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');

    if (errors.length > 0) {
      console.log('‚ùå Errors found:');
      errors.slice(0, 10).forEach(err => {
        console.log(`   Row ${err.row}: ${err.reason}`);
        console.log(`      Data: ${JSON.stringify(err.data)}`);
      });
      if (errors.length > 10) {
        console.log(`   ... and ${errors.length - 10} more errors\n`);
      }
      console.log('');
    }

    if (autogeneratedEmails.length > 0) {
      console.log('‚ö†Ô∏è  Autogenerated emails (missing or invalid email format):');
      autogeneratedEmails.slice(0, 10).forEach(entry => {
        console.log(`   ${entry}`);
      });
      if (autogeneratedEmails.length > 10) {
        console.log(`   ... and ${autogeneratedEmails.length - 10} more autogenerated emails\n`);
      }
      console.log('');
    }

    if (duplicates.length > 0) {
      console.log('‚ö†Ô∏è  Duplicates skipped (within CSV):');
      duplicates.slice(0, 10).forEach(dup => {
        console.log(`   ${dup}`);
      });
      if (duplicates.length > 10) {
        console.log(`   ... and ${duplicates.length - 10} more duplicates\n`);
      }
      console.log('');
    }

    if (campersToInsert.length === 0) {
      console.log('‚ö†Ô∏è  No valid campers to import');
      await mongoose.disconnect();
      process.exit(0);
    }

    // Check for existing campers in database (by email)
    const existingCampers = await Camper.find({
      email: { $in: campersToInsert.map(c => c.email) },
      isDeleted: false,
    });

    const existingEmails = new Set(existingCampers.map(c => c.email.toLowerCase()));

    // Filter out campers that already exist
    const campersToCreate = campersToInsert.filter(camper => {
      const emailExists = existingEmails.has(camper.email.toLowerCase());

      if (emailExists) {
        duplicates.push(`${camper.firstName} ${camper.lastName} (${camper.email}) - email already exists in database`);
        return false;
      }
      return true;
    });

    if (campersToCreate.length === 0) {
      console.log('‚ö†Ô∏è  All campers already exist in the database');
      if (duplicates.length > 0) {
        console.log('\n‚ö†Ô∏è  Existing campers:');
        duplicates.slice(0, 20).forEach(dup => {
          console.log(`   ${dup}`);
        });
        if (duplicates.length > 20) {
          console.log(`   ... and ${duplicates.length - 20} more\n`);
        }
      }
      await mongoose.disconnect();
      process.exit(0);
    }

    // Batch insert campers
    console.log(`üöÄ Creating ${campersToCreate.length} campers...\n`);

    const batchSize = 100;
    let created = 0;
    let insertErrors: any[] = [];
    let duplicateEmails: string[] = [];

    for (let i = 0; i < campersToCreate.length; i += batchSize) {
      const batch = campersToCreate.slice(i, i + batchSize);

      try {
        await Camper.insertMany(batch, { ordered: false });
        created += batch.length;
      } catch (error: any) {
        // Handle bulk write errors (duplicate emails, validation errors, etc.)
        if (error.writeErrors) {
          for (const writeError of error.writeErrors) {
            const failedCamper = batch[writeError.index];
            const errorCode = writeError.err?.code || writeError.code;

            // Extract error message
            let errorMsg = '';
            if (writeError.err?.errmsg) {
              errorMsg = writeError.err.errmsg;
            } else if (writeError.errmsg) {
              errorMsg = writeError.errmsg;
            } else if (writeError.err?.message) {
              errorMsg = writeError.err.message;
            } else if (writeError.message) {
              errorMsg = writeError.message;
            } else {
              errorMsg = JSON.stringify(writeError.err || writeError);
            }

            if (errorCode === 11000) {
              // Duplicate key error (unique email constraint)
              duplicateEmails.push(`${failedCamper.firstName} ${failedCamper.lastName} (${failedCamper.email})`);
            } else {
              insertErrors.push({
                camper: `${failedCamper.firstName} ${failedCamper.lastName}`,
                email: failedCamper.email,
                error: errorMsg,
                code: errorCode,
              });
            }
          }
          // Count successfully inserted records
          created += batch.length - error.writeErrors.length;
        } else if (error.errors) {
          // Mongoose validation errors
          const validationErrors = Object.keys(error.errors).map(key => {
            return `${key}: ${error.errors[key].message}`;
          }).join('; ');
          insertErrors.push({
            batch: `Batch starting at index ${i}`,
            error: `Validation error: ${validationErrors}`,
          });
        } else {
          // Other errors
          insertErrors.push({
            batch: `Batch starting at index ${i}`,
            error: error.message || JSON.stringify(error),
          });
        }
      }

      const progress = ((created / campersToCreate.length) * 100).toFixed(1);
      process.stdout.write(`\r   Progress: ${created}/${campersToCreate.length} (${progress}%)`);
    }

    console.log('\n\n‚úÖ Import completed!\n');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('üìä Final Statistics');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log(`Campers created:         ${created}`);
    console.log(`Duplicates skipped:      ${duplicates.length}`);
    console.log(`Autogenerated emails:    ${autogeneratedEmails.length}`);
    console.log(`Email duplicates:        ${duplicateEmails.length}`);
    console.log(`Validation errors:       ${errors.length}`);
    console.log(`Insert errors:           ${insertErrors.length}`);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');

    if (duplicateEmails.length > 0) {
      console.log('‚ö†Ô∏è  Duplicate emails (skipped during insert):');
      duplicateEmails.slice(0, 10).forEach(dup => {
        console.log(`   ${dup}`);
      });
      if (duplicateEmails.length > 10) {
        console.log(`   ... and ${duplicateEmails.length - 10} more duplicate emails\n`);
      }
      console.log('');
    }

    if (insertErrors.length > 0) {
      console.log('‚ùå Insert errors:');
      insertErrors.slice(0, 10).forEach(err => {
        const errorDetails = err.code ? `[Code: ${err.code}] ` : '';
        const emailInfo = err.email ? ` (${err.email})` : '';
        console.log(`   ${err.camper || err.batch}${emailInfo}: ${errorDetails}${err.error}`);
      });
      if (insertErrors.length > 10) {
        console.log(`   ... and ${insertErrors.length - 10} more errors\n`);
      }
      console.log('');
    }

    logger.info('Bulk camper creation completed', {
      created,
      duplicates: duplicates.length,
      autogeneratedEmails: autogeneratedEmails.length,
      emailDuplicates: duplicateEmails.length,
      validationErrors: errors.length,
      insertErrors: insertErrors.length,
    });

    await mongoose.disconnect();
    process.exit(0);
  } catch (error) {
    logger.error('Error creating campers:', error);
    console.error('\n‚ùå Error creating campers:', error);
    await mongoose.disconnect();
    process.exit(1);
  }
};

// Run the script
bulkCreateCampers();

